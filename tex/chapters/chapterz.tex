\newpage

{\color{red}
  VIDE
}
\newpage
\chapter{Vers les bases de données graphe}
\label{ch:graph-db}
Avec le développement rapide et continu de l'Internet et le cloud
computing, divers types d'applications ont émergés, ce qui augmente
l'mportance accrue de la technologie de base de données, notamment
dans les aspects suivants \cite{han2011survey}:

\begin{itemize}
\item Haute concurrente de lecture et d'écriture avec une faible
  latence.
\item Stockage et la gestion d'une grande masse de données \emph{(Big
    Data)}.
\item Haute scalabilité (évolutivité) et disponibilité.
\end{itemize}

Bien que les bases de données relationnelles ont occupé une grande
position dans le domaine de stockage de données, le modèle relationnel
commençait à montrer ses limites en faisant face au-dessus exigences:

\begin{itemize}
\item Lente lecture et l'écriture.
\item Capacité limitée.
\item Difficulté d'expansion et scalabilité.
\end{itemize}

Afin de faire face aux limitations ci-dessus, une variété de nouveaux
types de bases de données ont été apparus qui s'affranchissent du
modèle relationnel pour miser sur le partitionnement horizontal et le
relâchement des contraintes d'intégrité, ce modèle émergent est appelé
le modèle \acrshort{nosql}. Dans ce chapitre, nous exposons les
différentes approches et plateformes du stockage \textsc{NoSQL} les
plus connues dans l'industrie tout en mettant l'accent sur les bases
de données graphes (et \emph{Neo4j} particulièrement). Nous commençons
d'abord par présenter les quatre catégories majeurs des systèmes
\textsc{NoSQL}. Ensuite, nous focalisons sur les \acrshort{SGBD}
orientés graphes, leurs différents modèles et implémentations ainsi que
les langages de requête les plus adoptés pour les interroger.


\section{L'environnement NoSQL}
\label{sec:nosql}
\acrshort{nosql} désigne une catégorie de systèmes de gestion de base
de données (\acrshort{SGBD}) qui n'est plus fondée sur l'architecture
classique des bases relationnelles. L'unité logique n'y est plus la
table, et les données ne sont en général pas manipulées avec
\textsc{SQL}. À l'origine, servant à manipuler des bases de données
géantes pour des sites web de très grande audience tels que Google
Amazon, Facebook et eBay.

\newpage
  \subsection{Catégories des bases de données NoSQL}
  \label{4nosql}
  En bref, les bases de données \textsc{NoSQL} peuvent être
  catégorisées selon leur modèle de données dans les quatres
  catégories suivantes:

  \begin{itemize}
  \item [Dépots clés-valeurs]: Le principe des bases
    \textit{clé/valeur} est de stocker les données sous une forme
    simple: une \emph{clé } (chaîne de caractères) associé à une
    \emph{valeur} (chaîne de caractère, nombre ou bien un objet
    sérialisé), cette clé est utilisée pout toutes les opérations à
    effectuer sur les données telles que l'insertion, la mise à jour
    et la supression. Bien que la structure est plus simple, la
    vitesse d'interrogation est extrêmement supérieur à la base de
    données relationnelles favorisant la scalabilité
    (\emph{scalability}) plus que la cohérence. Les solutions les plus
    connues (redis \footnote{\url{http://www.redis.io}},
    Riak\footnote{\url{http://basho.com/riak/}} et
    voldemort\footnote{\url{http://www.project-voldemort.com/voldemort/}})
    sont principalement influencés par le project \emph{Dynamo}
    d'Amazon \cite{decandia2007dynamo}.

  \item [Orientées documents]: Cette famille de base de données est
    une évolution de la base de données \textit{clé/valeur} destinée
    aux applications qui gèrent des documents (généralement du format
    \textsc{JSON} ou \textsc{XML}) où chaque clé n'est plus associée à
    une valeur sous forme de bloc binaire mais à un document dont la
    structure reste libre (\textit{scheme-less}). L'avantage est de
    pouvoir récupérer, via une seule clé, un ensemble d’informations
    structurées de manière hiérarchique. ansi que le stockage de
    volumes très importants de données pour lesquelles la modélisation
    relationnelle aurait entraînée une limitation des possibilités de
    partitionnement et de réplication. les deux implémentations les
    plus populaires dans cette catégorie sont
    CouchDB\footnote{\url{http://couchdb.apache.org/}} d'Apache et
    MongoDB\footnote{\url{http://www.mongodb.org/}}.

  \item [Orientées colonnes]: Une base de données orientée colonnes
    est une base de données qui stocke les données par colonne et non
    par ligne. L'orientation colonne permet d'ajouter des colonnes
    plus facilement aux tables (les lignes n'ont pas besoin d'être
    redimensionnées). Elle permet de plus une compression par colonne,
    efficace lorsque les données de la colonne se ressemblent. Comme
    solutions, on retrouve principalement
    HBase\footnote{\url{http://hbase.apache.org/}},
    HyperTable\footnote{\url{http://hypertable.org/}} (implémentations
    Open Source du modèle \emph{BigTable} \cite{chang2008bigtable}
    publié par Google) ainsi que
    Cassandra\footnote{\url{http://cassandra.apache.org/}} (projet
    Apache qui respecte l'architecture distribuée de \emph{Dynamo}
    \cite{decandia2007dynamo} d'Amazon et le modèle BigTable de
    Google).

  \item [Orientées graphes]: %TODO
  \end{itemize}

  \subsection{Comparaison}
  \label{nosql-comp}

  %% pourquoi les bases de données graphes?
\newpage
\section{Bases de données orientées graphes}
\label{sec:graph-database-overview}
% TODO: rewrite the intro
\begin{text}
  Un grand nombre de problèmes pratiques dans différentes disciplines
  peuvent être intuitivement représentés sous forme de graphes : des
  nœuds reliés par des arcs (étiqueté ou non).

  Depuis plusieurs décennies, les développeurs ont essayé de stoker
  des ensembles de données connectés, semi-structurées à l'intérieur
  des bases de données relationnelles. Mais alors que les bases de
  données relationnelles ont été initialement conçues pour codifier
  des structures tabulaires. Cependant, les données fortement
  connectées sont traitées de manière très pauvre par les bases de
  données relationnelles. Chaque opération sur une relation dans un
  graphes ou réseau résulte en une opération de jointure dans le
  \acrshort{SGBDR}, implémentée comme une opération ensembliste entre
  l'ensemble des clés primaires de deux tables - une opération lente
  et sans capacité à monter en charge alors que le nombre de t-uples
  de ces tables augmente \cite{robinson2013graph}.

  Les bases de données orientées graphes sont donc conçues pour
  modéliser des réseaux de données fortement connectées et y naviguer
  facilement en bénéficiant de performances extrêmement élevées – un
  atout qui explique leur succès auprès de
  Facebook\footnote{\url{http://www.facebook.com}},
  LinkedIn\footnote{\url{http://www.linkedin.com}} et autres réseaux
  sociaux. Ces derniers sont devenus ces dernières années l'un de cas
  d'utilisation les plus visibles des bases de données graphes.
  LinkedIn parvient ainsi facilement à afficher le degré de séparation
  entre chaque contact, qui n'est finalement que la distance entre les
  nœuds dans le graphes représentant les personnes et leurs relations.
\end{text}

% TODO: relational vs graph database
  \subsection{Techniques de persistance des bases de données graphes}
  \label{sec:persistence-tech}

  \begin{itemize}
  \item [Bases de données graphes au-dessus de d'un stockage SQL]
  \item [Bases de données graphes au-dessus d'un stackages NoSQL]
  \item [Les bases de données graphes natives]
  \end{itemize}

  \subsection{Détails d'implémentation}
  \label{graph-internals}
  \begin{itemize}
  \item [Index-free adjacency]
  \item [Vertex Centric Indices]
  \item [Bitmaps representation of graphs]
  \item [Write Ahead Log]
  \end{itemize}

  \subsection{Comparaison}
  \label{graphdb-comp}

\newpage
\section{Langages d'interrogation des bases de données graphes}
\label{query-languages}
% TODO: intro

Les langages de requêtes ont toujours été la clé du succès des
systèmes de gestion des bases de données. La prévalence des
\acrshort{SGBDR} dans les dernières décennies ets étroitement couplé
avec le succès du \textsc{SQL}. Des divers langages d'interrogation
inventés
% TODO: make a simple graph example

  \subsection{SPARQL}
  \label{sparql}


  {\color{red}
    \url{http://franz.com/agraph/support/documentation/current/sparql-tutorial.html}
  }\newpage

  SPARQL [25] is a query language for RDF data and is recognized as
  one of the key technologies of the semantic web. It can extract
  values from structured and semi- structured data and supports
  unambiguous queries. A SPARQL endpoint accepts queries and returns
  results via HTTP, the results of SPARQL queries can be returned
  and/or rendered in a variety of formats such as XML, HTML or
  JSON. So it can be adapt by web service like REST server easily.  To
  give an example of how SPARQL works, we will do a query on DBPedia,
  which we mention in RDF section. This query will return the result
  of people born before 1900 in China form DBPedia, and sorted by
  names:

  SELECT ?name ?birth ?death ?person WHERE {
    ?person dbo:birthPlace :China .
    ?person dbo:birthDate ?birth .
    ?person foaf:name ?name.
    ?person dbo:deathDate ?death .
    FILTER (?birth <”1900-01-01”8sd:date) .
  }

  ORDER BY ?nam

  The first line defines the resource of RDF dataset, then it provides
  the request result columns and the query condition. SPARQL variables
  start with a question mark and can match any node (resource or
  literal) in the dataset. This query can be tested on a SPARQL query
  explorer on http://dbpedia.org/snorql/ provided by OpenLink
  Virtuoso.  SPARQL is supported by some databases such as
  AllegroGraph natively. Other graph databases like Neo4j also support
  SPARQL by applying plugin Linked Data.

  \subsection{Gremlin}
  \label{gremlin}

  {\color{red}
    \url{https://github.com/tinkerpop/gremlin/wiki}
  }

  Gremlin is a graph query language based on the open source software
  Blueprints.  It can be used on all of the graph databases that
  support Blueprints. It can be used in various JVM languages such as
  Java, and Groovy. By working with Blueprint API, Gremlin can be used
  to manipulate the graph database. It provides a command line prompt
  to insert/update/delete the nodes and edges. As a query language, it
  can perform complex graph traversals compactly. To get the same
  query result, it uses much less code than using Java API. For
  instance, it just needs 3 lines to get eigenvector centrality of a
  graph:

  m = [:]; c = 0;
  g.V.as(’x’).out.groupCount(m).loop(’x’){c++ <1000}
  m.sort { -it.value }


  Another important feature of Gremlin is there are many add-ons and
  connectors on it. For example, the JUNG algorithms library gives
  Gremlin the ability to compute centrality score, or do a clustering
  on the graph. The connector LinkedData Sail makes Gremlin easily
  access RDF just like SPARQL. Besides gremlin, some graph database
  vendor also provide their own query language, such as Cypher from
  Neo4j. There is a performance comparison in [26] that concludes
  Cypher is more syntax friendly to the SQL users but the gremlin has
  a little performance advantage when running the query.  Considering
  its compatibility and pluggable nature, Gremlin should be the
  initial choice as the query language for graph database.

  \subsection{Cypher}

  {\color{red}
    \url{http://neo4j.com/docs/stable/cypher-introduction.html}\\
    \url{https://github.com/neo4j-contrib/manual-french/blob/master/po/cypher.po}
  }



  {\color{red}
    compare gremlin and cypher using\cite{holzschuher2013performance}
  }

\section{Conclusion}

  % TODO: Neo4j internals
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
