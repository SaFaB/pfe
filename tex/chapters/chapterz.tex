\chapter{Vers les bases de données graphe}
\label{ch:graph-db}
Avec le développement rapide et continu de l'Internet et le cloud
computing, divers types d'applications ont émergés, ce qui augmente
l'mportance accrue de la technologie de base de données, notamment
dans les aspects suivants \cite{han2011survey}:

\begin{itemize}
\item Haute concurrente de lecture et d'écriture avec une faible
  latence.
\item Stockage et la gestion d'une grande masse de données \emph{(Big
    Data)}.
\item Haute scalabilité (évolutivité) et disponibilité.
\end{itemize}

Bien que les bases de données relationnelles ont occupé une grande
position dans le domaine de stockage de données, le modèle relationnel
commençait à montrer ses limites en faisant face au-dessus exigences:

\begin{itemize}
\item Lente lecture et l'écriture.
\item Capacité limitée.
\item Difficulté d'expansion et scalabilité.
\end{itemize}

Afin de faire face aux limitations ci-dessus, une variété de nouveaux
types de bases de données ont été apparus qui s'affranchissent du
modèle relationnel pour miser sur le partitionnement horizontal et le
relâchement des contraintes d'intégrité, ce modèle émergent est appelé
le modèle \acrshort{nosql}. Dans ce chapitre, nous exposons les
différentes approches et plateformes du stockage \textsc{NoSQL} les
plus connues dans l'industrie tout en mettant l'accent sur les bases
de données graphes (et \emph{Neo4j} particulièrement). Nous commençons
d'abord par présenter les quatre catégories majeurs des systèmes
\textsc{NoSQL}. Ensuite, nous focalisons sur les \acrshort{SGBD}
orientés graphes, leurs différents modèles et implémentations ainsi que
les langages de requête les plus adoptés pour les interroger.


\section{L'environnement NoSQL}
\label{sec:nosql}
% TODO: make a real definition
\acrshort{nosql} désigne une catégorie de systèmes de gestion de base
de données (\acrshort{SGBD}) qui n'est plus fondée sur l'architecture
classique des bases relationnelles. L'unité logique n'y est plus la
table, et les données ne sont en général pas manipulées avec
\textsc{SQL}. À l'origine, servant à manipuler des bases de données
géantes pour des sites web de très grande audience tels que Google
Amazon, Facebook et eBay.

  \subsection{Catégories des bases de données NoSQL}
  \label{4nosql}
  En bref, les bases de données \textsc{NoSQL} peuvent être
  catégorisées selon leur modèle de données dans les quatres
  catégories suivantes:

  \begin{itemize}
  \item [Dépots clés-valeurs]: Le principe des bases
    \textit{clé/valeur} est de stocker les données sous une forme
    simple: une \emph{clé } (chaîne de caractères) associé à une
    \emph{valeur} (chaîne de caractère, nombre ou bien un objet
    sérialisé), cette clé est utilisée pout toutes les opérations à
    effectuer sur les données telles que l'insertion, la mise à jour
    et la supression. Bien que la structure est plus simple, la
    vitesse d'interrogation est extrêmement supérieur à la base de
    données relationnelles favorisant la scalabilité
    (\emph{scalability}) plus que la cohérence. Les solutions les plus
    connues (redis \footnote{\url{http://www.redis.io}},
    Riak\footnote{\url{http://basho.com/riak/}} et
    voldemort\footnote{\url{http://www.project-voldemort.com/voldemort/}})
    sont principalement influencés par le project \emph{Dynamo}
    d'Amazon \cite{decandia2007dynamo}.

  \item [Orientées documents]: Cette famille de base de données est
    une évolution de la base de données \textit{clé/valeur} destinée
    aux applications qui gèrent des documents (généralement du format
    \textsc{JSON} ou \textsc{XML}) où chaque clé n'est plus associée à
    une valeur sous forme de bloc binaire mais à un document dont la
    structure reste libre (\textit{scheme-less}). L'avantage est de
    pouvoir récupérer, via une seule clé, un ensemble d’informations
    structurées de manière hiérarchique. ansi que le stockage de
    volumes très importants de données pour lesquelles la modélisation
    relationnelle aurait entraînée une limitation des possibilités de
    partitionnement et de réplication. les deux implémentations les
    plus populaires dans cette catégorie sont
    CouchDB\footnote{\url{http://couchdb.apache.org/}} d'Apache et
    MongoDB\footnote{\url{http://www.mongodb.org/}}.

  \item [Orientées colonnes]: Une base de données orientée colonnes
    est une base de données qui stocke les données par colonne et non
    par ligne. L'orientation colonne permet d'ajouter des colonnes
    plus facilement aux tables (les lignes n'ont pas besoin d'être
    redimensionnées). Elle permet de plus une compression par colonne,
    efficace lorsque les données de la colonne se ressemblent. Comme
    solutions, on retrouve principalement
    HBase\footnote{\url{http://hbase.apache.org/}},
    HyperTable\footnote{\url{http://hypertable.org/}} (implémentations
    Open Source du modèle \emph{BigTable} \cite{chang2008bigtable}
    publié par Google) ainsi que
    Cassandra\footnote{\url{http://cassandra.apache.org/}} (projet
    Apache qui respecte l'architecture distribuée de \emph{Dynamo}
    \cite{decandia2007dynamo} d'Amazon et le modèle BigTable de
    Google).

  \item [Orientées graphes]: %TODO
  \end{itemize}

  \subsection{Comparaison}
  \label{nosql-comp}

  %% pourquoi les bases de données graphes?
\section{Bases de données orientées graphes}
\label{sec:graph-database-overview}
% TODO: rewrite the intro
\begin{text}
  Un grand nombre de problèmes pratiques dans différentes disciplines
  peuvent être intuitivement représentés sous forme de graphes : des
  nœuds reliés par des arcs (étiqueté ou non).

  Depuis plusieurs décennies, les développeurs ont essayé de stoker
  des ensembles de données connectés, semi-structurées à l'intérieur
  des bases de données relationnelles. Mais alors que les bases de
  données relationnelles ont été initialement conçues pour codifier
  des structures tabulaires. Cependant, les données fortement
  connectées sont traitées de manière très pauvre par les bases de
  données relationnelles. Chaque opération sur une relation dans un
  graphes ou réseau résulte en une opération de jointure dans le
  \acrshort{SGBDR}, implémentée comme une opération ensembliste entre
  l'ensemble des clés primaires de deux tables - une opération lente
  et sans capacité à monter en charge alors que le nombre de t-uples
  de ces tables augmente \cite{robinson2013graph}.

  Les bases de données orientées graphes sont donc conçues pour
  modéliser des réseaux de données fortement connectées et y naviguer
  facilement en bénéficiant de performances extrêmement élevées – un
  atout qui explique leur succès auprès de
  Facebook\footnote{\url{http://www.facebook.com}},
  LinkedIn\footnote{\url{http://www.linkedin.com}} et autres réseaux
  sociaux. Ces derniers sont devenus ces dernières années l'un de cas
  d'utilisation les plus visibles des bases de données graphes.
  LinkedIn parvient ainsi facilement à afficher le degré de séparation
  entre chaque contact, qui n'est finalement que la distance entre les
  nœuds dans le graphes représentant les personnes et leurs relations.
\end{text}

% TODO: relational vs graph database
  \subsection{Techniques de persistance des bases de données graphes}
  \label{sec:persistence-tech}

  \begin{itemize}
  \item [Bases de données graphes au-dessus de d'un stockage SQL]
  \item [Bases de données graphes au-dessus d'un stackages NoSQL]
  \item [Les bases de données graphes natives]
  \end{itemize}

  \subsection{Détails d'implémentation}
  \label{graph-internals}
  \begin{itemize}
  \item [Index-free adjacency]
  \item [Vertex Centric Indices]
  \item [Bitmaps representation of graphs]
  \item [Write Ahead Log]
  \end{itemize}

  \subsection{Comparaison}
  \label{graphdb-comp}

\newpage
\section{Langages d'interrogation des bases de données graphes}
\label{query-languages}

Les langages de requêtes ont toujours été la clé du succès des
systèmes de gestion des bases de données. La prévalence des
\emph{\acrshort{SGBDR}} dans les dernières décennies est étroitement
couplé avec le succès du \emph{SQL}. Des divers langages ont été
définis pour exprimer des requêtes vis-à-vis plusieurs dépôts de
données, par exemple, \emph{XQuery} \cite{boag2002xquery} et
\emph{XPath} \cite{clark1999xml} pour les bases de données
\emph{\acrshort{xml}}, \emph{QQL} \cite{alashqur1989oql} pour les
bases de données orientées objets et \emph{SPARQL}
\cite{prud2008sparql} pour les triplestores (les bases de données
\emph{RDF}). Dans cette section on va présenter les langages de
requêtes les plus utilisée pour l'interrogation des bases de données
graphes.

  % TODO: make a simple graph example
  \subsection{SPARQL}
  \label{sparql}

  \begin{text}
  SPARQL \cite{prud2008sparql} is a query language for RDF data and is
  recognized as one of the key technologies of the semantic web. It
  can extract values from structured and semi-structured data and
  supports unambiguous queries. A SPARQL endpoint accepts queries and
  returns results via HTTP, the results of SPARQL queries can be
  returned and/or rendered in a variety of formats such as XML, HTML
  or JSON. So it can be adapt by web service like REST server easily.
  To give an example of how SPARQL works, we will do a query on
  DBPedia, which we mention in RDF section. This query will return the
  result of people born before 1900 in China form DBPedia, and sorted
  by names:

  SELECT ?name ?birth ?death ?person WHERE {
    ?person dbo:birthPlace :China .
    ?person dbo:birthDate ?birth .
    ?person foaf:name ?name.
    ?person dbo:deathDate ?death .
    FILTER (?birth <”1900-01-01”8sd:date) .
  }

  ORDER BY ?nam

  The first line defines the resource of RDF dataset, then it provides
  the request result columns and the query condition. SPARQL variables
  start with a question mark and can match any node (resource or
  literal) in the dataset. This query can be tested on a SPARQL query
  explorer on http://dbpedia.org/snorql/ provided by OpenLink
  Virtuoso.  SPARQL is supported by some databases such as
  AllegroGraph natively. Other graph databases like Neo4j also support
  SPARQL by applying plugin Linked Data.
  \end{text}% TODO: translate

  \subsection{Gremlin}
  \label{sec:gremlin}

  \emph{Gremlin} \cite{gremlin-wiki} est un projet open source
  développé et maintenu par TinkerPop, \emph{Gremlin} est un langage
  de domaine spécifique (\acrshort{DSL}) pour le parcours des graphes
  (), il trouve ses applications dans les domaines de la recherche,
  l'analyse et la manipulation des bases de données orientées graphes
  qui implémentent le modèle \emph{Blueprints} \cite{blueprints} de
  données (\emph{modèle de graphe attribué}).

  La syntaxe \emph{Gremlin} est basée sur \emph{XPath} de manière à
  être capable d'exprimer des descriptions de parcours même profonds
  avec des expressions simples.

  \subsection{Cypher}
  \label{sec:cypher}
  \emph{Cypher} \cite{cypher-docs} est un langage des requêtes
  déclaratif pour interagir avec les bases des données graphes
  \emph{Neo4j}, développé et maintenu par \emph{Neo Technology}. Il
  permet d'effectuer des requêtes et mises jour du graphe efficaces
  sans avoir écrire de traversiers (parcours) d'une manière
  procédurale.

  En étant un langage déclaratif, \emph{Cypher} se concentre sur la
  clarté d'exprimer \textit{quoi retrouver dans un graphe et non
    comment le faire}. Ceci est en contraste aux langages impératifs
  comme Java et aux langages script comme \emph{Gremlin}
  \ref{gremlin}, ce qui rend le fait d'optimisation de requêtes un
  détail d'implémentation non exposé aux utilisateurs. \emph{Cypher}
  est inspiré de plusieurs approches et construit sur des pratiques
  établies pour l'interrogation expressif des bases de données. La
  plupart des mots clés comme \verb|WHERE| et \verb|ORDER BY|, et La
  concordance de patterns sont hérités directement des langages
  déclaratifs comme \emph{SQL} et \emph{SPARQL} \ref{sparql} avec
  quelque propriétés inspirés des langages fonctionnels comme
  \emph{Haskell} et \emph{ML}.

  Le langage \emph{Cypher} comporte un nombre de clauses distinctes,
  des clauses pour l'interrogation du graphe comme:
  \begin{itemize}
  \item [\texttt{MATCH}]: Utilisé pour pour décrire Le pattern du graphe
    à correspondre, principalement sur la base de relations entre les
    nœuds du graphe.
  \item [\texttt{WHERE}]: Sert à un critère de filtrage.
  \item [\texttt{RETURN}]: Spécifie ce qu'il faut retourner comme
    résultat finale de requête.
  \end{itemize}


  \emph{Cypher} contient en outre des clauses pour l'écriture, la mise
  à jour et suppression de données, par exemple:

  \begin{itemize}
  \item [\texttt{CREATE}]: Crée des nœuds ou des relations.
  \item [\texttt{SET}]: Affecte des valeurs aux propriétés..
  \item [\texttt{DELETE}]: supprime des noeuds, relations ou propriétés.
  \end{itemize}

  \section{Conclusion}

  % TODO: Neo4j internals
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../main"
%%% End:
